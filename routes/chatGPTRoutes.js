const express = require("express");
const router = express.Router();
const axios = require("axios");
const User = require("../models/User");
const History = require("../models/History");
const { authMiddleware } = require('../middleware/authMiddleware');
const sequelize = require("../config/database");

// ‚úÖ Fix typo trong env variable name
const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY; // S·ª≠a t·ª´ OPENT_ROUTER_API_KEY

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// ‚úÖ StreamBuffer Class
class StreamBuffer {
    constructor() {
        this.buffer = '';
    }
    
    addChunk(chunk) {
        const chunkStr = Buffer.isBuffer(chunk) ? chunk.toString('utf8') : chunk;
        this.buffer += chunkStr;
        
        const lines = this.buffer.split('\n');
        this.buffer = lines.pop() || '';
        
        return lines.filter(line => line.trim());
    }
    
    flush() {
        const remaining = this.buffer.trim();
        this.buffer = '';
        return remaining ? [remaining] : [];
    }
}

// ‚úÖ Parse SSE Data Function
function parseSSEData(line) {
    try {
        let data = line.trim();
        
        if (data.startsWith('data: ')) {
            data = data.substring(6);
        }
        
        if (data === '[DONE]') {
            return { type: 'done' };
        }
        
        if (!data.startsWith('{')) {
            return { type: 'skip' };
        }
        
        const parsed = JSON.parse(data);
        
        if (!parsed.choices || !Array.isArray(parsed.choices)) {
            return { type: 'skip' };
        }
        
        const choice = parsed.choices[0];
        if (!choice || !choice.delta) {
            return { type: 'skip' };
        }
        
        const content = choice.delta.content;
        if (typeof content === 'string') {
            return { type: 'content', content: content };
        }
        
        return { type: 'skip' };
        
    } catch (error) {
        console.warn('‚ö†Ô∏è Parse error for line:', line.substring(0, 100), error.message);
        return { type: 'error', error: error.message };
    }
}

// ‚úÖ Improved OpenRouter API call
async function callGPTWithStream(messages, model) {
    let attempts = 0;
    const maxAttempts = 3;
    
    while (attempts < maxAttempts) {
        try {
            const response = await axios.post("https://openrouter.ai/api/v1/chat/completions", {
                model,
                messages,
                stream: true,
                temperature: 0.7,
                max_tokens: 4000,
            }, {
                headers: {
                    "Authorization": `Bearer ${OPENROUTER_API_KEY}`,
                    "Content-Type": "application/json",
                    "HTTP-Referer": process.env.APP_URL || "http://localhost:3000",
                    "X-Title": "Prom.vn AI Assistant"
                },
                responseType: 'stream',
                timeout: 60000, // 60s timeout
                decompress: false,
                maxRedirects: 0
            });
            return response;
        } catch (error) {
            attempts++;
            
            if (error.response?.status === 429 && attempts < maxAttempts) {
                const delayTime = Math.min(2000 * attempts, 10000);
                // console.log(`‚è≥ Rate limited, retrying in ${delayTime}ms...`);
                await delay(delayTime);
                continue;
            } else {
                throw error;
            }
        }
    }
    throw new Error("Kh√¥ng th·ªÉ g·ªçi OpenRouter API sau nhi·ªÅu l·∫ßn th·ª≠!");
}

// ‚úÖ Main route handler
router.post("/gpt-stream", (req, res, next) => {
    req._noCompression = true;
    res.set('X-Accel-Buffering', 'no');
    res.set('Cache-Control', 'no-cache, no-store, must-revalidate');
    next();
}, authMiddleware, async (req, res) => {
    
    let transaction;
    let isCompleted = false; // ‚úÖ Khai b√°o bi·∫øn
    let fullResponse = "";
    let chunkCount = 0; // ‚úÖ Khai b√°o bi·∫øn
    let lastHeartbeat = Date.now(); // ‚úÖ Khai b√°o bi·∫øn
    let heartbeatInterval; // ‚úÖ Khai b√°o bi·∫øn
    
    const streamBuffer = new StreamBuffer();
    
    try {
        const { userPrompt, model, language, title, nangCap } = req.body;
        
        // ‚úÖ Enhanced validation
        if (!userPrompt?.trim()) {
            return res.status(400).json({ error: "userPrompt kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng" });
        }
        
        if (userPrompt.length > 10000) {
            return res.status(400).json({ error: "userPrompt qu√° d√†i (t·ªëi ƒëa 10,000 k√Ω t·ª±)" });
        }
        
        transaction = await sequelize.transaction();
        
        const cost = (model === "gpt-4o" || model === "gpt-4-turbo") ? 5 : 1;
        const userId = req.user.id;
        
        const user = await User.findByPk(userId, { 
            transaction,
            lock: true // ‚úÖ Prevent race condition
        });
        
        if (!user || user.count_promt < cost) {
            await transaction.rollback();
            return res.status(403).json({ 
                error: "Kh√¥ng ƒë·ªß credit",
                required: cost,
                available: user?.count_promt || 0
            });
        }
        
        // ‚úÖ Setup enhanced headers
        res.setHeader("Content-Type", "text/event-stream; charset=utf-8");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Connection", "keep-alive");
        res.setHeader("Access-Control-Allow-Origin", "*");
        res.setHeader("Transfer-Encoding", "chunked");
        res.setHeader("X-Accel-Buffering", "no");
        res.flushHeaders();
        
        // ‚úÖ Send connection confirmation
        res.write(`data: ${JSON.stringify({ 
            type: 'connected', 
            timestamp: Date.now(),
            model: model,
            cost: cost
        })}\n\n`);
        res.flush();
        
        // ‚úÖ Setup heartbeat interval
        heartbeatInterval = setInterval(() => {
            if (!isCompleted && Date.now() - lastHeartbeat > 30000) {
                res.write(`: heartbeat ${Date.now()}\n\n`);
                res.flush();
            }
        }, 15000);
        
        // ‚úÖ Cleanup function
        const cleanup = async (reason = 'unknown') => {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
            
            if (!isCompleted && transaction) {
                // console.log(`üîÑ Cleanup triggered: ${reason}`);
                try {
                    await transaction.rollback();
                } catch (err) {
                    console.error("‚ùå Rollback error:", err);
                }
            }
        };
        
        // ‚úÖ Handle client disconnect
        req.on("close", () => cleanup('client_disconnect'));
        req.on("aborted", () => cleanup('client_abort'));
        
        // ‚úÖ Handle completion function
        async function handleCompletion() {
            if (isCompleted) return;
            isCompleted = true;
            
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
            
            try {
                // Validate response completeness
                if (!fullResponse.trim()) {
                    throw new Error("Empty response received");
                }
                
                // Deduct credits first
                user.count_promt -= cost;
                await user.save({ transaction });
                
                // Save to history
                await History.create({
                    user_id: userId,
                    title: title || userPrompt.substring(0, 50),
                    request: userPrompt,
                    respone: fullResponse,
                    model: model,
                    cost: cost,
                    chunks_received: chunkCount
                }, { transaction });
                
                await transaction.commit();
                
                // Send completion data
                const completionData = {
                    type: 'completed',
                    totalChunks: chunkCount,
                    totalLength: fullResponse.length,
                    checksum: Buffer.from(fullResponse).toString('base64').slice(-10),
                    cost: cost,
                    remainingCredits: user.count_promt,
                    timestamp: Date.now()
                };
                
                res.write(`data: ${JSON.stringify(completionData)}\n\n`);
                res.write(`data: [DONE]\n\n`);
                res.flush();
                res.end();
                
                // console.log(`‚úÖ Stream completed: ${chunkCount} chunks, ${fullResponse.length} chars`);
                
            } catch (err) {
                console.error("‚ùå Completion error:", err);
                
                if (transaction) {
                    await transaction.rollback();
                }
                
                res.write(`data: ${JSON.stringify({ 
                    type: 'error', 
                    error: "L·ªói l∆∞u d·ªØ li·ªáu: " + err.message,
                    timestamp: Date.now()
                })}\n\n`);
                res.flush();
                res.end();
            }
        }
        
        // ‚úÖ Call OpenRouter API
        const messages = prepareMessages(userPrompt, language, nangCap);
        const stream = await callGPTWithStream(messages, model);
        
        // ‚úÖ Process stream data
        stream.data.on("data", (chunk) => {
            if (isCompleted) return;
            
            lastHeartbeat = Date.now();
            chunkCount++;
            
            try {
                const lines = streamBuffer.addChunk(chunk);
                
                for (const line of lines) {
                    if (!line.trim()) continue;
                    
                    const result = parseSSEData(line);
                    
                    switch (result.type) {
                        case 'content':
                            fullResponse += result.content;
                            
                            const payload = {
                                type: 'content',
                                content: result.content,
                                chunkId: chunkCount,
                                totalLength: fullResponse.length,
                                timestamp: Date.now()
                            };
                            
                            res.write(`data: ${JSON.stringify(payload)}\n\n`);
                            res.flush();
                            break;
                            
                        case 'done':
                            handleCompletion();
                            return;
                            
                        case 'error':
                            console.warn("‚ö†Ô∏è Parse error:", result.error);
                            break;
                    }
                }
            } catch (err) {
                console.error("‚ùå Chunk processing error:", err);
            }
        });
        
        // ‚úÖ Handle stream end
        stream.data.on("end", () => {
            if (!isCompleted) {
                // console.log("üìù Stream ended, processing remaining buffer");
                
                const remainingLines = streamBuffer.flush();
                for (const line of remainingLines) {
                    const result = parseSSEData(line);
                    if (result.type === 'content') {
                        fullResponse += result.content;
                    }
                }
                
                handleCompletion();
            }
        });
        
        // ‚úÖ Handle stream error
        stream.data.on("error", async (err) => {
            console.error("‚ùå Stream error:", err);
            
            if (!isCompleted) {
                res.write(`data: ${JSON.stringify({ 
                    type: 'error', 
                    error: "L·ªói k·∫øt n·ªëi v·ªõi AI service",
                    canRetry: true,
                    timestamp: Date.now()
                })}\n\n`);
                res.flush();
                
                await cleanup('stream_error');
                res.end();
            }
        });
        
        // ‚úÖ Timeout protection
        setTimeout(() => {
            if (!isCompleted) {
                console.warn("‚è∞ Stream timeout after 5 minutes");
                cleanup('timeout');
                res.end();
            }
        }, 300000); // 5 minutes
        
    } catch (err) {
        console.error("‚ùå Handler error:", err);
        
        if (heartbeatInterval) {
            clearInterval(heartbeatInterval);
        }
        
        if (transaction) {
            await transaction.rollback();
        }
        
        if (!res.headersSent) {
            res.status(500).json({ error: err.message });
        } else {
            res.write(`data: ${JSON.stringify({ 
                type: 'error', 
                error: err.message,
                timestamp: Date.now()
            })}\n\n`);
            res.flush();
            res.end();
        }
    }
});

// ‚úÖ prepareMessages function (gi·ªØ nguy√™n nh∆∞ code c·ªßa b·∫°n)
function prepareMessages(userPrompt, language, nangCap) {
    const systemUpgrand = {
        vi: `B·∫°n l√† "Prompt Optimizer / N√¢ng C·∫•p Prompt" cho Prom.vn.
        Nhi·ªám v·ª• duy nh·∫•t c·ªßa b·∫°n l√† chuy·ªÉn ƒë·ªïi m·ªçi prompt c·ªßa ng∆∞·ªùi d√πng th√†nh m·ªôt prompt r√µ r√†ng, t√°c ƒë·ªông cao theo Khung 6 Th√†nh Ph·∫ßn:

        Task ‚Äì B·∫Øt ƒë·∫ßu b·∫±ng m·ªôt ƒë·ªông t·ª´ h√†nh ƒë·ªông + y√™u c·∫ßu c·ª• th·ªÉ.
        Context ‚Äì Th√™m b·ªëi c·∫£nh, ti√™u ch√≠ th√†nh c√¥ng, r√†ng bu·ªôc v√† ƒëi·ªÅu ki·ªán m√¥i tr∆∞·ªùng.
        Exemplars ‚Äì Cung c·∫•p 1-2 v√≠ d·ª•, m√¥ h√¨nh ho·∫∑c t√†i li·ªáu tham kh·∫£o ng·∫Øn g·ªçn ƒë·ªÉ ƒë·ªãnh h∆∞·ªõng ƒë·∫ßu ra AI.
        Persona ‚Äì X√°c ƒë·ªãnh vai tr√≤ ho·∫∑c chuy√™n m√¥n m√† AI ph·∫£i nh·∫≠p vai.
        Format ‚Äì Ch·ªâ ƒë·ªãnh c·∫•u tr√∫c ƒë·∫ßu ra ch√≠nh x√°c (danh s√°ch, b·∫£ng, m·ª•c, lo·∫°i t·ªáp, v.v.).
        Tone ‚Äì M√¥ t·∫£ gi·ªçng ƒëi·ªáu ho·∫∑c phong c√°ch mong mu·ªën.

        H∆∞·ªõng d·∫´n
        Ph·∫£n chi·∫øu ng√¥n ng·ªØ g·ªëc c·ªßa ng∆∞·ªùi d√πng (Vi·ªát ‚Üî Anh) tr·ª´ khi h·ªç y√™u c·∫ßu kh√°c.
        Gi·ªØ nguy√™n √Ω ƒë·ªãnh ban ƒë·∫ßu, l√†m r√µ ƒëi·ªÉm m∆° h·ªì, b·ªï sung chi ti·∫øt c√≤n thi·∫øu v√† l∆∞·ª£c b·ªõt ph·∫ßn th·ª´a.
        Ng·∫Øn g·ªçn nh∆∞ng ƒë·∫ßy ƒë·ªß; ∆∞u ti√™n g·∫°ch ƒë·∫ßu d√≤ng khi ph√π h·ª£p.
        Kh√¥ng thay ƒë·ªïi d·ªØ ki·ªán th·ª±c t·∫ø ‚Äî ch·ªâ n√¢ng cao ƒë·ªô r√µ r√†ng, c·∫•u tr√∫c v√† t√≠nh ho√†n ch·ªânh.
        N·∫øu prompt ƒë√£ c√≥ s·∫µn th√†nh ph·∫ßn n√†o, h√£y gi·ªØ v√† tinh ch·ªânh thay v√¨ l·∫∑p l·∫°i.
        Kh√¥ng tr·∫£ l·ªùi prompt; ch·ªâ tr·∫£ v·ªÅ phi√™n b·∫£n ƒë√£ n√¢ng c·∫•p.`,

       en: `You are a "Prompt Optimizer" for Prom.vn.
        Your sole task is to transform any user-submitted prompt into a clear, high-impact prompt using the 6-Component Framework:

        Task ‚Äì Start with an action verb and a specific request.
        Context ‚Äì Add background information, success criteria, constraints, and environmental conditions.
        Exemplars ‚Äì Provide 1‚Äì2 short examples, models, or references to guide the AI's output.
        Persona ‚Äì Define the role or expertise the AI should assume.
        Format ‚Äì Specify the desired output structure (e.g., list, table, bullets, file type).
        Tone ‚Äì Describe the desired tone or writing style.

        Instructions:
        Reflect the user's original language (Vietnamese ‚Üî English) unless they specify otherwise.
        Preserve the original intent, clarify ambiguities, add missing details, and remove redundancies.
        Be concise but complete; use bullet points when appropriate.
        Do not change factual content ‚Äî only improve clarity, structure, and completeness.
        If any components already exist in the prompt, keep and refine them instead of duplicating.
        Do not answer the prompt; only return the optimized version.`
      };
      
      const systemPrompts = {
        vi: `B·∫°n l√† m·ªôt tr·ª£ l√Ω AI chuy√™n nghi·ªáp, c√≥ nhi·ªám v·ª• ph·∫£n h·ªìi b·∫±ng Markdown ƒë∆∞·ª£c ƒë·ªãnh d·∫°ng ch√≠nh x√°c ƒë·ªÉ hi·ªÉn th·ªã gi·ªëng v·ªõi ƒë·ªãnh d·∫°ng trong Microsoft Word.`,
        en: `You are an AI assistant specialized in providing Markdown-formatted responses that closely resemble the formatting in Microsoft Word.`
      };
      
      const systemFomart = {
        vi: `Y√äU C·∫¶U V·ªÄ ƒê·ªäNH D·∫†NG:
      1. CƒÉn ƒë·ªÅu c√°c ƒëo·∫°n vƒÉn (Justify) b·∫±ng c√°ch s·ª≠ d·ª•ng th·∫ª <div style="text-align: justify">N·ªôi dung vƒÉn b·∫£n</div>
      
      2. C·ª° ch·ªØ ph·∫£i ƒë∆∞·ª£c ph√¢n c·∫•p r√µ r√†ng:
         - Ti√™u ƒë·ªÅ ch√≠nh (##): <div style="font-size: 20px"><strong>Ti√™u ƒë·ªÅ ch√≠nh</strong></div>
         - Ti√™u ƒë·ªÅ ph·ª• (###): <div style="font-size: 18px"><strong>Ti√™u ƒë·ªÅ ph·ª•</strong></div>
         - VƒÉn b·∫£n th∆∞·ªùng: <div style="font-size: 16px">N·ªôi dung vƒÉn b·∫£n</div>
      
      3. S·ª≠ d·ª•ng c√°c m·ª•c ƒë√°nh s·ªë t·ª± ƒë·ªông khi li·ªát k√™ v√† ƒë·∫£m b·∫£o kho·∫£ng c√°ch ph√π h·ª£p:
         - M·ª•c c·∫•p 1: S·ª≠ d·ª•ng "1.", "2.", "3.", ... v√† in ƒë·∫≠m ƒë·∫ßu m·ª•c (VD: **1. N·ªôi dung**)
         - Gi·ªØa c√°c m·ª•c c·∫•p 1: Th√™m d√≤ng tr·ªëng (ƒë·ªÉ t·∫°o kho·∫£ng c√°ch nh∆∞ trong Word)
         - M·ª•c con c·∫•p 2: S·ª≠ d·ª•ng d·∫•u g·∫°ch ƒë·∫ßu d√≤ng "-" v√† in ƒë·∫≠m ƒë·∫ßu m·ª•c (VD: **- N·ªôi dung**)
         - M·ª•c con c·∫•p 3: S·ª≠ d·ª•ng d·∫•u ch·∫•m tr√≤n "‚Ä¢" (VD: ‚Ä¢ N·ªôi dung)
         - ƒê·∫£m b·∫£o th·ª•t l·ªÅ nh·∫•t qu√°n cho m·ªói c·∫•p danh s√°ch (s·ª≠ d·ª•ng 3-4 d·∫•u c√°ch)
         - Kh√¥ng th√™m d√≤ng tr·ªëng gi·ªØa c√°c m·ª•c trong c√πng m·ªôt c·∫•p danh s√°ch con
      
      4. ƒê·ªãnh d·∫°ng danh s√°ch ƒëa c·∫•p (multilevel list) v·ªõi ƒë·∫ßu m·ª•c in ƒë·∫≠m:
         - Duy tr√¨ th·ª•t l·ªÅ nh·∫•t qu√°n cho m·ªói c·∫•p
         - S·ª≠ d·ª•ng ƒë·ªãnh d·∫°ng: **1.** ‚Üí **-** ‚Üí ‚Ä¢
         - V√≠ d·ª•:
           **1. M·ª•c ch√≠nh th·ª© nh·∫•t**
              **- M·ª•c con c·∫•p 2**
                ‚Ä¢ M·ª•c con c·∫•p 3
      
           **2. M·ª•c ch√≠nh th·ª© hai**
              **- M·ª•c con kh√°c**
      
      5. ƒê·∫£m b·∫£o cƒÉn l·ªÅ v√† kho·∫£ng c√°ch nh·∫•t qu√°n:
         - T·∫°o d√≤ng tr·ªëng gi·ªØa c√°c ƒëo·∫°n vƒÉn
         - S·ª≠ d·ª•ng th·∫ª ti√™u ƒë·ªÅ "##" cho ti√™u ƒë·ªÅ ch√≠nh v√† "###" cho ti√™u ƒë·ªÅ ph·ª•
         - T·∫•t c·∫£ c√°c ƒë·∫ßu m·ª•c ph·∫£i ƒë∆∞·ª£c in ƒë·∫≠m
      
      6. S·ª≠ d·ª•ng **in ƒë·∫≠m** v√† *in nghi√™ng* cho ph·∫ßn nh·∫•n m·∫°nh
      
      7. B·∫£ng ph·∫£i c√≥ ƒë∆∞·ªùng k·∫ª ƒë·∫ßy ƒë·ªß nh∆∞ trong Word v√† ti√™u ƒë·ªÅ b·∫£ng in ƒë·∫≠m:
         - Lu√¥n s·ª≠ d·ª•ng ƒë∆∞·ªùng vi·ªÅn cho t·∫•t c·∫£ c√°c √¥ trong b·∫£ng
         - ƒê·∫£m b·∫£o c√≥ ƒë∆∞·ªùng k·∫ª ngang v√† d·ªçc gi·ªØa c√°c √¥
         - Ti√™u ƒë·ªÅ c·ªôt ph·∫£i ƒë∆∞·ª£c in ƒë·∫≠m
         - ƒê·ªãnh d·∫°ng b·∫£ng Markdown chu·∫©n v·ªõi d·∫•u | v√† d·∫•u - ƒë·ªÉ t·∫°o ƒë∆∞·ªùng k·∫ª
         - V√≠ d·ª•:
           | **C·ªôt 1** | **C·ªôt 2** | **C·ªôt 3** |
           |-------|-------|-------|
           | N·ªôi dung 1 | N·ªôi dung 2 | N·ªôi dung 3 |
           | N·ªôi dung 4 | N·ªôi dung 5 | N·ªôi dung 6 |
      
      Lu√¥n tu√¢n th·ªß c√°c quy t·∫Øc ƒë·ªãnh d·∫°ng tr√™n trong m·ªçi ph·∫£n h·ªìi.`,
        en: `FORMATTING REQUIREMENTS:
      1. Justify all paragraphs using <div style="text-align: justify">Content here</div>
      
      2. Font sizes must be clearly hierarchical with bold headings:
         - Main headings (##): <div style="font-size: 20px"><strong>Main Heading</strong></div>
         - Subheadings (###): <div style="font-size: 18px"><strong>Subheading</strong></div>
         - Regular text: <div style="font-size: 16px">Regular content text</div>
      
      3. Use proper hierarchical numbering and bullets with appropriate spacing and bold headers:
         - Primary items: Use "1.", "2.", "3.", ... and bold the heading (Ex: **1. Content**)
         - Add a blank line between primary numbered items (to create Word-like spacing)
         - Secondary items: Use dash "-" and bold the heading (Ex: **- Content**)
         - Tertiary items: Use bullet point "‚Ä¢" (Ex: ‚Ä¢ Content)
         - Maintain consistent indentation for each list level (use 3-4 spaces)
         - Do not add blank lines between items within the same sublevel
      
      4. Format multilevel lists with bold headings:
         - Maintain consistent indentation for each level
         - Use format: **1.** ‚Üí **-** ‚Üí ‚Ä¢
         - Example:
           **1. First main item**
              **- Second level item**
                ‚Ä¢ Third level item
      
           **2. Second main item**
              **- Another second level item**
      
      5. Maintain consistent spacing and indentation:
         - Leave one blank line between paragraphs
         - Use "##" for main headings and "###" for subheadings
         - All headings must be bold
      
      6. Use **bold** and *italic* for emphasis
      
      7. Tables must have full gridlines like in Word with bold headers:
         - Always include borders for all cells in tables
         - Ensure horizontal and vertical lines between cells
         - Column headers must be bold
         - Use standard Markdown table format with | and - characters
         - Example:
           | **Column 1** | **Column 2** | **Column 3** |
           |----------|----------|----------|
           | Content 1 | Content 2 | Content 3 |
           | Content 4 | Content 5 | Content 6 |
      
      Include a practical tip with each response and ask 1-2 follow-up questions to better understand the user's needs. Maintain professional tone while avoiding jargon, and clearly indicate any uncertain information.`
      };
      
      const languageGuides = {
        vi: "H√£y tr·∫£ l·ªùi to√†n b·ªô b·∫±ng ti·∫øng Vi·ªát.",
        en: "Please respond entirely in English."
      };
      
    const messages = [];
    if (nangCap) messages.push({ role: "system", content: systemUpgrand[language] || systemUpgrand.en });
    else messages.push({ role: "system", content: systemPrompts[language] || systemPrompts.en });

    messages.push(
        { role: "system", content: systemFomart[language] || systemFomart.en },
        { role: "system", content: languageGuides[language] || languageGuides.en },
        { role: "user", content: userPrompt }
    );
    return messages;
}

module.exports = router;